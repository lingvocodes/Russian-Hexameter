# -*- coding: cp1251 -*-
import codecs, re, math, pdb


# функции расчёта среднего  коэффициента коэффициента корреляции без использования модуля numpy
# в данный момент не используются. Проедполагалось, что разлиным слогам с неоднозначным ударением присваивается числовое значение вероятности ударности (от 0 до 1)
#  после чего вычисляется коэффициент корреляции между имеющейся схемой и эталонными, с выбором схемы, дающей наибольшую корреляцию.
# В контексте сделанных допущейний подобный подход является мало полезным и правктически не охватывает имеющиеся неоднозначные случаи

def average(x):
    assert len(x) > 0
    return float(sum(x)) / len(x)

def pearson_def(x, y):
    assert len(x) == len(y)
    n = len(x)
    assert n > 0
    avg_x = average(x)
    avg_y = average(y)
    diffprod = 0
    xdiff2 = 0
    ydiff2 = 0
    for idx in range(n):
        xdiff = x[idx] - avg_x
        ydiff = y[idx] - avg_y
        diffprod += xdiff * ydiff
        xdiff2 += xdiff * xdiff
        ydiff2 += ydiff * ydiff

    return diffprod / math.sqrt(xdiff2 * ydiff2)



# список гласных. Только строчные, т.к. везде используется .lower()
vowels = u"уеыаоэяиюё"

# список клитик, для которых принимается решенние о безударности
spec_w = [u"про",u"под", u"над", u"без", u"меж", u"подо", u"при", u"со", u"и", u"у", u"среди", u"обо", u"сквозь", u"ото", u"для"]

# массив возмжных ударных схем для 17-, 16- и 15-сложных строк
shape = [['-UU-UU-UU-UU-UU-U'],
['-U-UU-UU-UU-UU-U', '-UU-U-UU-UU-UU-U',    '-UU-UU-U-UU-UU-U',    '-UU-UU-UU-U-UU-U',    '-UU-UU-UU-UU-U-U'],
['-U-U-UU-UU-UU-U', '-U-UU-U-UU-UU-U', '-UU-U-U-UU-UU-U', '-U-UU-UU-U-UU-U', '-UU-U-UU-U-UU-U', '-UU-UU-U-U-UU-U',  '-U-UU-UU-UU-U-U', '-UU-U-UU-UU-U-U',    '-UU-UU-U-UU-U-U',    '-UU-UU-UU-U-U-U']]

# массив с количественными результатами распознавания: 
way_detect=[[0,0,0],[0,0,0],[0,0,0]]

# имя обрабатываемого файла
filename=u'tst1.txt'

##U_scheme=[]
##for j in range(18):
##    row= [0]*(j+1)
##    U_scheme.append(row)
# текст с ударением от акцентуатора    
f = codecs.open(filename, 'r', 'utf-8')
# файл с создаваемой схемой
newtext = codecs.open(u'sovest_scheme_'+filename, 'w', 'utf-8')
k=0 
lnn=0

# чтение строки из файла
for line in f:
    m=0         # число гласных в строке (число слогов)
    lnn+=1      # номер строки
    ud=''       # схема ударений в строке
    ud_a=''     # схема ударений в строке согласно акцентуатору

    # пословное рассмотрение строки
    for word in line.lower().split():
        w_ud=''     #схема ударений в слове
        m1=0        # число слогов в слове
        p=0         #номер буквы в слове
        e_case=0    # в слове есть ё
        word+='z'   # чтобы не создавать ошибку при обращении к несуществующему элементу строки при проверке ударности последнего гласного в слове и не писать исключение, добавляем один символ
        n_ud=0      # число ударений в слове согласно акцентуатору
        #создание схемы ударений для каждого слова согласно акцентуатору
        for j in word:
            p+=1
            if j in vowels:
                m1 +=1
                m +=1

                # если в слове есть "ё", помечаем его особым символом на схеме ударений, потому что этот слог точно будет ударным, а у акцентуатора не обязательно
                if (j==u'ё'):
                    w_ud+='W'
                    e_case=1
                else:
                    if (word[p]=="'")|(m==1):
                        w_ud+='-'
                        n_ud+=1
                        ud_a+='-'
                    else:
                        w_ud+='U'
                        ud_a+='U'                        

        # применение набора исключений для слов
                    
        #если акцентуатор не поставил ни одного ударения, обозначаем каждый слог слова как 0
        if (n_ud==0)&(e_case==0):
            w_ud=w_ud.replace('U','0')
            
        #если в слове 1 слог, обозначаем его через 1, т.к. акцентуатор не стави ударения в односложных словах. Ударность/безударность определяется исходя из вида прилежащих слогов
        if m1==1:
            w_ud='1'
            
        #если акцентуатор ставит более одного ударения, каждый из варантов обозначаем через H, чтобы впоследствии оставить один наиболее подходящий
        if n_ud==2:
            w_ud=w_ud.replace("-",'H')

        # Если акцентуатор ставит 3 возможных ударения в слове - особый случай
        # в дальнейшем рассмотрении не используется

        elif n_ud==3:
            w_ud=w_ud.replace("-",'K')
            
        # если в слове есть ё, то именно этот слог ударный, что бы там ни думал акцентуатор
        if e_case==1:
            w_ud=w_ud.replace('-','U')
            w_ud=w_ud.replace('W','-')
        temp2=word.strip(".,?/-!'`()[]:;z")
        temp2=temp2.replace("'",'')
        
        # клитики c большой вероятностью являются безударными
        if temp2 in spec_w:
            w_ud=w_ud.replace('1','U')
            w_ud=w_ud.replace('-','U')


        # если в слове более 3 слогов, то, вероятно, оно подчиняется стандартной схеме гекзаметра, проставляем недостающие ударения
        if m1>3:
            a=w_ud.find('-')
            if a>-1:
                w_ud=''
                for i in range(m1):
                    if (i%3)==(a%3): w_ud+='-'
                    else: w_ud+='U'

        # Зачастую вместо "её" в тексте написано "ее", и акцентуатор, естественно, не справляется. Помогаем ему с этим.
        if word==u'ееz':
            w_ud='U-'
        ud+=w_ud


    # Когда схема строки построена, проверяем, хватает ли возможностей акцентуатора для точного восстановления схемы. Если да, то ему зачёт, переходим к следующей строке    
    if (len(ud_a)==m)&(ud_a in shape[m%3]):
        way_detect[0][(17-m)%3]+=1
    else:
        line_ok=0
        changes=1
        ud0=ud

        # циклический анализ неоднозначных ударений в строке с коррекцией до тех пор, пока есть такая возможность или пока не получится однозначная схема
        while (line_ok==0)&(changes>0)&(ud!=''):
            changes=0
            temp2=ud[:2]

            # схема первых двух слогов всегда -U. Если она не такая, исправляем. Если при этом один из слогов был с неоднозначным ударением (Н), то теперь мы точно знаем схему ударений во всём слове, и проставляем её
            if temp2!='-U':
                ud='-U'+ud[2:]
                if (temp2[0]=='H')&(temp2!='HH'):
                    ud=ud.replace('H', 'U',1)
                    changes+=1
                if (temp2[1]=='H')&(temp2!='HH'):
                    ud=ud.replace('H', '-',1)
                    changes+=1
            # схема последних двух слогов всегда -U. Если она не такая, исправляем. Если при этом один из слогов был с неоднозначным ударением (Н), то теперь мы точно знаем схему ударений во всём слове, и проставляем её
            temp2=ud[m-2:]
            if temp2!='-U':
                ud=ud[:m-2]+'-U'
                if (temp2[0]=='H')&(temp2!='HH'):
                    ud=ud[::-1].replace('H', 'U',1)[::-1]
                    changes+=1
                if (temp2[1]=='H')&(temp2!='HH'):
                    ud=ud[::-1].replace('H', '-',1)[::-1]
                    changes+=1                    
            # односложное слово после ударного слога всегда безударное
            if ("-1" in ud):
                ud=ud.replace('-1', '-U')
                changes+=1
            # односложное слово перед ударным слогом всегда безударное
            if ("1-" in ud):
                ud=ud.replace('1-', 'U-')
                changes+=1
            # односложное слово после двух безударных слогов всегда ударное
            if ("UU1" in ud):
                ud=ud.replace('UU1', 'UU-')
                changes+=1
            # однослодное слово перед двумя безудраными слогами всегда ударное    
            if ("1UU" in ud):
                ud=ud.replace('1UU', '-UU')
                changes+=1

            # если есть 5 неоднозначных слогов между двумя ударными - схема -UU-UU-    
            tmp0=re.compile(r"-\w{5}-")
            tmp1=re.search(tmp0, ud)
            if tmp1!=None:
                ud=ud.replace(tmp1.group(), "-UU-UU-")
                changes+=1

            # если после/перед ударным слоговм идет неоднозначный - он безударный, а другой в этом слове - ударный.    
            tmp2=ud.find('-H')
            if tmp2!=-1:
                ud=ud.replace('-H', '-U')
                tmp2+=1
                ud=ud[:tmp2]+ud[tmp2:].replace('H','-',1)
            tmp2=ud.find('H-')
            if tmp2!=-1:
                ud=ud.replace('H-', 'U-')
                ud=ud[tmp2::-1].replace('H','-',1)[::-1]+ud[tmp2+1:]

            # если в 16, 13, 10 -сложной строке встречается (однократно) последовательность ударный-безударный-ударный, она может полностью определять схему строки
            if (('-U-' in ud)&((m%3)==1)):
                a0=ud.index('-U-')
                if ((ud.count('-U-')==1)&(a0%3==0)):
                    ud=shape[1][a0//3]
                    ud=ud[:m]
                    #print ud.index('-U-'),' line:', lnn, ', dl ', m, '\n'
                    changes+=1
                    
            #print 'line: "', lnn, ' check ', ud.count('-')+ud.count('U'), '    ', m, ' changes ', changes

            # Если в строке остались только 'U' и '-' , анализ окончен
            if (ud.count('-')+ud.count('U')==m): line_ok=1
            #print ud.count('-')+ud.count('U'), '=?=', m
            
        if line_ok==1:
            way_detect[1][(17-m)%3]+=1
            
        else:
            way_detect[2][(17-m)%3]+=1
            if m<17:
                newtext.write('\r\n'+line)
                newtext.write(ud0+ '\r\n')
    if m<17:
        newtext.write(ud+ '  '+ '%d'%m+'\r\n')
    #newtext.write(line + '%d' % lnn + '  ' + '%d' % m + '  ' +  ud + '\r\n')
    #newtext.write('%d' % lnn + '  ' + '%d' % m + '  ' +  ud0 + '\r\n')
    k+=1

        
if k == 0: newtext.write('а нет таких')
print 'Обработано строк текста: ', lnn

print 'число слогов в строке', [17,16,15]
print 'Однозначно определено акцентуатором',  way_detect[0]
print 'Ударных схем идентифицировано',  way_detect[1]
print 'Схем не идентифицировано',  way_detect[2]


newtext.close()
f.close()
          




